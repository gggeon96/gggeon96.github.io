---
layout: post
title: 렌더링엔진
subtitle: 렌더링엔진에 대해서 알아보자
categories: cs
tags: [web, cs]
published: true
---

# 그림으로 보는 브라우저의 동작, 구성요소
<img src="C:\Users\geon1\Desktop\gggeon96.github.io\assets\images\2023-05-12-렌더링엔진\rendering.png" alt="rendering" style="zoom:50%;" />

<img src="C:\Users\geon1\Desktop\gggeon96.github.io\assets\images\2023-05-12-렌더링엔진\rendering-2.png" alt="rendering-2" style="zoom:80%;" />

렌더링 엔진 & js 엔진

| UserInterface                                                | \- 사용자가 접근할 수 있는 영역이다. - 예를 들어, 검색창, 뒤로가기/앞으로가기 버튼, 새로 고침 버튼 등 브라우저 프로그램 자체의 GUI를 구성하는 부분이다. |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| BrowserEngine                                                | \- User Interface와 Rendering Engine 사이의 동작을 제어해주는 엔진이다. - 브라우저라는 프로그램의 비즈니스 로직, 핵심 중추 부분이다. - Data Storage를 참조하며 로컬에 데이터를 쓰고 읽으면서 다양한 작업을 한다. |
| Rendering Engine                                             | \- 요청한 콘텐츠를 화면에 출력하는 역할이다.                 |
| \- HTML, CSS 등을 파싱하여 최종적으로 화면에 그린다. ←오늘 볼 곳 |                                                              |
| Networking                                                   | \- http 요청을 할 수 있으며 네티워크를 호출할 수 있다.       |
| JS Engine                                                    | \- javascript 코드를 해석하고 실행한다.                      |
| UI Backend                                                   | \- 기본적인 위젯을 그리는 인터페이스이다.                    |
| Data Storage                                                 | \- Local Storage, Indexed DB, 쿠키 등 브라우저 메모리를 활용하여 저장하는 영역이다. |

# 렌더링 엔진 종류 및 특징

<img src="C:\Users\geon1\Desktop\gggeon96.github.io\assets\images\2023-05-12-렌더링엔진\rendering-engines.png" alt="rendering-engines" style="zoom:75%;" />

## **WebKit 엔진**

![rendering-webkit](C:\Users\geon1\Desktop\gggeon96.github.io\assets\images\2023-05-12-렌더링엔진\rendering-webkit.png)

**1)** DOM tree 생성 : Conversion - Tokenizing - Lexing 이후에 DOM 생성

**2)** CSSOM 생성 : Conversion - Tokenizing - Lexing 이후에 CSSOM 생성

**3)** Render Tree(DOM + CSSOM) 생성 - Attachment

**4)** 배치 및 그리기 : 시각적으로 처리되는 렌더트리를 레이아웃에 배치한 뒤 렌더링 트리의 각 노드들을 화면의 픽셀별로 나타낸다.

WebKit 엔진은 오픈소스 웹 브라우저로 Safari 그리고 과거의 Chrome이 사용했다. 또한 아이폰, 안드로이드 브라우저 들이 모두 웹킷 엔진이다.

## **GecKo 엔진**

![rendering-gecko](C:\Users\geon1\Desktop\gggeon96.github.io\assets\images\2023-05-12-렌더링엔진\rendering-gecko.png)

**1)** Content Sink에서 DOM 노드를 만들어 Content Model 생성

**2)** CSSOM(CSS Object Model) 생성

**3)** Frame Tree 생성 - Frame Constructor

**4)** 배치 및 그리기 : Reflow에서 노드를 배치하고 Frame tree를 Painting 한다.

마찬가지로 GecKo 엔진도 오픈 소스로 파이어폭스, Mozilla, 구글 가젯 등이 Gecko 엔진을 사용한다.

## **Blink 엔진**

![rendering-blink](C:\Users\geon1\Desktop\gggeon96.github.io\assets\images\2023-05-12-렌더링엔진\rendering-blink.png)

Blink 엔진은 Webkit 엔진이 포킹된 것으로 브라우저는 선택된 자원을 화면에 표시해주고 여러 개의 WebContents를 포함하고 있다. 멀티 프로세스 애플리케이션의 한 부분으로 사용하도록 최적화 되어 있다고 한다.

대표적으로 Chrome이 Blink엔진을 사용한다. + 삼성 브라우저 <<

# 렌더링 엔진의 동작 과정

## DOM트리 구축, CSSOM 트리 구축 단계

![rendering-step](C:\Users\geon1\Desktop\gggeon96.github.io\assets\images\2023-05-12-렌더링엔진\rendering-step.png)

DOM(Document Object Model), CSSOM(Css Object MOdel)의 약자임!

DOM은 HTML을 파싱해서 만든 모델이다. 이 DOM노드들을 병합해서 DOM트리 구조를 만든다. CSSOM은 CSS를 파싱하여 CSSOM트리를 만들게 된다.

브라우저는 렌더링 할 문서를 CSS, HTML로 나눠서 읽는다.

일련의 과정들이 점진적으로 진행된다는 것을 아는 것이 중요하다. 렌더링 엔진은 좀 더 나은 사용자 경험을 위해 가능하면 빠르게 내용을 표시하는데 모든 HTML을 파싱할 때까지 기다리지 않고 배치와 그리기 과정을 시작한다. 네트워크로부터 나머지 내용이 전송되기를 기다리는 동시에 받은 내용의 일부를 먼저 화면에 표시하는 것이다.

### HTML파싱과 DOM생성

![rendering-parsing](C:\Users\geon1\Desktop\gggeon96.github.io\assets\images\2023-05-12-렌더링엔진\rendering-parsing.png)

1.  서버는 브라우저로부터 요청 받은 HTML 파일을 읽고 → 메모리에 저장하고 → 그 메모리에 저장된 바이트`(101101000100…)`를 응답한다.
2.  브라우저는 응답 받은 바이트 형태의 문서를 meta태그의 charset attribute에 지정된 인코딩방식(UTF-8)에 따라 문자열로 반환한다.
3.  문자열로 변환된 HTML문서를 이번에는 문법적 의미를 갖는 코드의 최소 단위인 토큰(token)으로 분해한다.
4.  토큰들의 내용에 따라 객체로 변환하여 각 노드들을 생성한다. (문서 노드, 요소 노드, 어트리뷰트 노드, 텍스트 노드)
5.  HTML은 요소 간의 부자 관계인 중첩 관계를 갖는데, 이를 반영하여 모든 노드들을 트리 구조로 구성하여 DOM을 만든다.

### CSS파싱과 CSSOM 생성 과정

렌더링 엔진은 HTML문서를 한줄 한줄 순차적으로 파싱하며 DOM을 생성한다. 그러다 CSS를 로드하는 link태그 혹은 style태그를 만나면 DOM생성을 중지한 후 CSS파싱의 결과물인 CSSOM을 생성하는 과정을 진행한다.

```
<!DOCTYPE html>
<html><head><meta charset="UTF-8"> // 여기까지 해석 후,
  <link rel="stylesheet" href="style.css"> //link를 만나면 DOM생성을 중지하고 CSS파일을 서버에 요청한 후 응답받아 CSS파싱을 시작한다.
```

### 자바스크립싱

렌더링 엔진은 HTML 문서를 한 줄씩 순차적으로 파싱하다가 자바스크립트 파일을 로드하는 script 태그를 만나면 DOM 생성을 일시 중단한다.

script 태그의 src에 정의된 자바스크립트 파일을 서버에 요청하여 응답받으면 자바스크립트 코드를 파싱하기 위해 자바스크립트 엔진에게 제어권을 넘긴다.

자바스크립트 파싱이 끝나면 렌더링 엔진으로 다시 제어권을 넘기고 DOM 생성을 이어나간다.

만약 생성되지 않은 DOM을 조작한다면 에러가 발생할 수 있다. 따라서 body 요소 아래에 자바스크립트를 위치 시키거나 DOM 생성이 완료된 시점에 자바스크립트가 실행되도록 한다.

1.  자바스크립트 코드를 토크나이저가 어휘 분석하여 문법적 의미를 갖는 코드의 최소 단위인 토큰들로 분해하는데 이것을 토큰나이징이라 한다.
2.  파서가 토큰들을 구문분석하여 AST(Abstract Syntax Tree : 추상 구문 트리)로 파싱한다.
3.  바이트 코드 생성기가 AST를 바이트코드로 변환한다.
4.  인터프리터에 의해 바이트코드를 실행한다.

## 렌더 트리 구축

![rendering-tree](C:\Users\geon1\Desktop\gggeon96.github.io\assets\images\2023-05-12-렌더링엔진\rendering-tree.png)

CSSOM 트리와 DOM 트리를 결합하여, 표시해야 할 순서로 내용을 그려낼 수 있도록 하기 위해

**렌더 트리**를 형성한다. 이 과정을

**Attachment**라고 한다.

렌더 트리는 화면에 표시되는 각 노드의 위치를 계산하는 레이아웃에 사용되고 픽셀을 화면에 그리는 페인트 과정에도 사용된다.

_DOM과 CSSOM을 결합하여 렌더트리 생성_

렌더 트리를 생성하려면 브라우저는 대략 3가지 작업을 수행한다.

- DOM 트리의 루트부터 노드 각각을 모두 탐색한다.
  - 이 때 화면에 표시되지 않는 일부 노드들(script, meta 태그 등..)은 렌더 트리에서 제외된다.
  - 또한 CSS 속성 중 `display:none` 같이 화면에서 숨겨지는 속성도 렌더 트리에 반영되지 않는다.
- 화면에 표시되는 각 노드에 대해 적절하게 일치하는 CSSOM 규칙을 찾아 적용한다.
- 화면에 표시되는 노드를 콘텐츠 및 계산된 스타일과 함께 렌더트리로 생성된다.

## 렌더 트리 배치

렌더 트리가 생성되고, 기기의 뷰포트 내에서 렌더 트리의 노드가 정확한 위치와 크기를 계산한다. 이때 모든 상대적인 값이 픽셀값으로 변환된다. CSS에 상대적인 값인 `%`,`rem`,`vh`
으로 할당된 값들은 절대적인 값인 `px`단위로 변환 된다. 이 과정을 배치(**Layout**) 또는 **Reflow**라고 한다.

## 렌더 트리 그리기

렌더 트리의 각 노드를 화면의 실제 픽셀로 나타낼 때 **Painting**
메서드가 호출된다. Painting 과정 후 브라우저 화면에 UI가 나타나게 된다.

# Reflow와 Repaint

렌더링 과정을 모두 마친 후 최종적으로 브라우저에 페이지가 그려진다. 하지만 특정 액션이나 이벤트에 따라 HTML요소의 크기나 위치 등의 레이아웃 수치가 변하면 해당 요소의 영향을 받는 자식 노드나 부모 노드들을 포함하여 Layout(Reflow)과정을 다시 수행하게 된다.

이럴경우 각 요소들의 크기와 위치를 다시 계산하게 되는데 이 과정을 Reflow, 그리고 Reflow 된 렌더 트리를 다시 화면에 그려주는 과정을 Repaint라고 한다.

- Repaint(Redraw)는 화면에 변화가 있을 때 화면을 그리는 과정.
- Reflow(Layout)는 뷰포트 내에서 렌더 트리의 노드의 정확한 위치와 크기를 계산하는 과정.
- Repaint가 발생하는 경우는 화면이 변경되는 모든 경우.
- Reflow가 발생하는 경우는 화면의 구조가 바뀌었을 경우.

### Repaint

화면의 구조가 변경되었을 때에는 Reflow 과정을 거쳐 화면 구조를 다시 계산한 후 Repaint 과정을 통해 화면을 다시 그린다. 즉 화면의 구조가 변경되었을 때에는 Reflow와 Repaint 모두 발생한다.

화면의 구조가 변경되지 않는 화면 변화의 경우 Repaint만 발생한다. 예를 들면 `opacity`, `background-color`, `visibility`, `outline` 등의 스타일 변경 시에는 Repaint만 동작한다.

### Reflow

위에서 말한 것처럼 렌더 트리와 각 요소들의 크기와 위치를 다시 계산해주는 과정을 **Reflow**라고 한다.

Reflow가 일어나는 대표적인 경우는 다음과 같다.

- DOM 노드의 추가, 제거
- DOM 노드의 위치 변경
- DOM 노드의 크기 변경(margin, padding, border, width, height 등..)
- CSS3 애니메이션과 트랜지션
- 폰트 변경, 텍스트 내용 변경
- 이미지 크기 변경
- offset, scrollTop, scrollLeft과 같은 계산된 스타일 정보 요청
- 페이지 초기 렌더링
- 윈도우 리사이징

[Lighthouse 사용법](https://velog.io/@dell_mond/Lighthouse-%EC%82%AC%EC%9A%A9%EB%B2%95)
